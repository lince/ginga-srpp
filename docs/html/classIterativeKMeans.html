<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>ModuloRecommender: IterativeKMeans Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>IterativeKMeans Class Reference</h1><!-- doxytag: class="IterativeKMeans" --><code>#include &lt;<a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>&gt;</code>
<p>
Collaboration diagram for IterativeKMeans:<p><center><img src="classIterativeKMeans__coll__graph.png" border="0" usemap="#IterativeKMeans__coll__map" alt="Collaboration graph"></center>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classIterativeKMeans-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#fa7e74e26882ca65cd2bae4e2ab382e2">IterativeKMeans</a> (vector&lt; vector&lt; int &gt; &gt; <a class="el" href="classIterativeKMeans.html#853e96ad0ab7d4b27ff114465b3f27a5">points</a>)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; int &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#9a9cabf56c24e31041a64b2c9cdc18a7">getClusterIds</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; vector&lt; int &gt; &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#469cb603a67d9942ff661f6e37ad69ab">getCentroids</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#6eda24e89175954112eb3482a6df8edc">cluster</a> (int k)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#779451e9e689f50578f536bf4a0c4ef6">cluster</a> (int Minclus, int Maxclus)</td></tr>

<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#3e750fadbbabc5fd15bead0c8a258512">matrix2CB</a> (int **mat, int vecCount, int vecLen, <a class="el" href="structCODEBOOK.html">CODEBOOK</a> *CB)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#589582d0d0225e95a41c551a292dd424">RMSE</a> (double *x, double *y, int start, int end, double a, double b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#16426c4ce048fab6c21811e87a4e245b">getFunction</a> (double *x, double *y, int start, int end, double *a, double *b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#8814152ce1c4fa34746338d8a9c5b638">LMethod</a> (double *x, double *y, int N)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#5d6ed84980d598063b09676c472a7a85">predictedNumberClusters</a> (double *bicValues, int Minclus, int Maxclus)</td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="853e96ad0ab7d4b27ff114465b3f27a5"></a><!-- doxytag: member="IterativeKMeans::points" ref="853e96ad0ab7d4b27ff114465b3f27a5" args="" -->
vector&lt; vector&lt; int &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#853e96ad0ab7d4b27ff114465b3f27a5">points</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#f842fcee4e13cf8516379ed25ba363cc">clusterid</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; vector&lt; int &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIterativeKMeans.html#b42aafa792eefc3441e12abcf94bc4e9">centroids</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Iterative Clustering with prediction of number of clusters. Cluster method is k-means. Prediction of number of clusters uses L-Method and BIC. For a description of L-Method, see "Determining the Number of Clusters/Segments in Hierarchical Clustering/ Segmentation Algorithms", by Stan Salvador and Philip Chan. <dl class="author" compact><dt><b>Author:</b></dt><dd>Marco Cristo and Angelo Filipe. K-means code and some auxiliary code by Marco Tuononen (available at <a href="http://cs.joensuu.fi/~mtuonon/">http://cs.joensuu.fi/~mtuonon/</a>). BIC code by Qinpei Zhao (available at <a href="http://cs.joensuu.fi/~zhao/Software/">http://cs.joensuu.fi/~zhao/Software/</a>). </dd></dl>

<p>

<p>
Definition at line <a class="el" href="ikmeans_8h-source.html#l00028">28</a> of file <a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>.<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="fa7e74e26882ca65cd2bae4e2ab382e2"></a><!-- doxytag: member="IterativeKMeans::IterativeKMeans" ref="fa7e74e26882ca65cd2bae4e2ab382e2" args="(vector&lt; vector&lt; int &gt; &gt; points)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIterativeKMeans.html">IterativeKMeans</a>           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; int &gt; &gt;&nbsp;</td>
          <td class="paramname"> <em>points</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for <a class="el" href="classIterativeKMeans.html">IterativeKMeans</a>. 
<p>
Definition at line <a class="el" href="ikmeans_8h-source.html#l00098">98</a> of file <a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>.
<p>
References <a class="el" href="ikmeans_8h-source.html#l00031">points</a>.
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="3e750fadbbabc5fd15bead0c8a258512"></a><!-- doxytag: member="IterativeKMeans::matrix2CB" ref="3e750fadbbabc5fd15bead0c8a258512" args="(int **mat, int vecCount, int vecLen, CODEBOOK *CB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void matrix2CB           </td>
          <td>(</td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vecCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vecLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCODEBOOK.html">CODEBOOK</a> *&nbsp;</td>
          <td class="paramname"> <em>CB</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert integer matrix to internal KMeans Format. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>Pre-alocated integer matrix (int **m) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vecCount</em>&nbsp;</td><td>Number of lines in m (number of vectors) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vecLen</em>&nbsp;</td><td>Number of columns in m (vector dimension) </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="589582d0d0225e95a41c551a292dd424"></a><!-- doxytag: member="IterativeKMeans::RMSE" ref="589582d0d0225e95a41c551a292dd424" args="(double *x, double *y, int start, int end, double a, double b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double RMSE           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns root mean squared error between function ax + b and set of points (x,y) in interval [start,end). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Vector of x coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Vector of y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Interval start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Interval end. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Function slope. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Function intercept. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Root mean squared error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="16426c4ce048fab6c21811e87a4e245b"></a><!-- doxytag: member="IterativeKMeans::getFunction" ref="16426c4ce048fab6c21811e87a4e245b" args="(double *x, double *y, int start, int end, double *a, double *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getFunction           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds slope a and intercept b of best fit function of a set of points (x,y) in interval [start,end). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Vector of x coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Vector of y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>Interval start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>Interval end. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>Function slope. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>Function intercept. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Point which corresponds to line "knee". </dd></dl>

</div>
</div><p>
<a class="anchor" name="8814152ce1c4fa34746338d8a9c5b638"></a><!-- doxytag: member="IterativeKMeans::LMethod" ref="8814152ce1c4fa34746338d8a9c5b638" args="(double *x, double *y, int N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LMethod           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>N</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds "knee" of a line (given by its points [x,y]) using L-method. For a description of L-Method, see "Determining the Number of Clusters/Segments in Hierarchical Clustering/ Segmentation Algorithms", by Stan Salvador and Philip Chan. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>Vector of x coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>Vector of y coordinates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>Number of points. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Point which corresponds to line "knee". </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d6ed84980d598063b09676c472a7a85"></a><!-- doxytag: member="IterativeKMeans::predictedNumberClusters" ref="5d6ed84980d598063b09676c472a7a85" args="(double *bicValues, int Minclus, int Maxclus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int predictedNumberClusters           </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>bicValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Minclus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Maxclus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Predicts the number of clusters considering the BIC values associated with several different partitions. The bicValues correspond to partitions from Minclus to Maxclus clusters. This method can only be applied to a set with at least 4 partitions (4 points in the line function). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bicValues</em>&nbsp;</td><td>Vector of BIC values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Minclus</em>&nbsp;</td><td>Minimum number of clusters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Maxclus</em>&nbsp;</td><td>Maximum number of clusters. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of clusters. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a9cabf56c24e31041a64b2c9cdc18a7"></a><!-- doxytag: member="IterativeKMeans::getClusterIds" ref="9a9cabf56c24e31041a64b2c9cdc18a7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt;&amp; getClusterIds           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns cluster ids found after last clustering. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Vector of cluster ids. </dd></dl>

<p>
Definition at line <a class="el" href="ikmeans_8h-source.html#l00107">107</a> of file <a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>.
<p>
References <a class="el" href="ikmeans_8h-source.html#l00032">clusterid</a>.
</div>
</div><p>
<a class="anchor" name="469cb603a67d9942ff661f6e37ad69ab"></a><!-- doxytag: member="IterativeKMeans::getCentroids" ref="469cb603a67d9942ff661f6e37ad69ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt;&amp; getCentroids           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns centroids found after last clustering. <dl class="return" compact><dt><b>Returns:</b></dt><dd>Vector of centroids. </dd></dl>

<p>
Definition at line <a class="el" href="ikmeans_8h-source.html#l00115">115</a> of file <a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>.
<p>
References <a class="el" href="ikmeans_8h-source.html#l00033">centroids</a>.
</div>
</div><p>
<a class="anchor" name="6eda24e89175954112eb3482a6df8edc"></a><!-- doxytag: member="IterativeKMeans::cluster" ref="6eda24e89175954112eb3482a6df8edc" args="(int k)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cluster           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>k</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cluster the vectors in points into k clusters. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>k</em>&nbsp;</td><td>Number of clusters. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True, if clustering succeded. </dd></dl>

</div>
</div><p>
<a class="anchor" name="779451e9e689f50578f536bf4a0c4ef6"></a><!-- doxytag: member="IterativeKMeans::cluster" ref="779451e9e689f50578f536bf4a0c4ef6" args="(int Minclus, int Maxclus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cluster           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Minclus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Maxclus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform clustering on vectors in points, choosing the best partition from Minclus to Maxclus clusters. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Minclus</em>&nbsp;</td><td>Minimum number of clusters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Maxclus</em>&nbsp;</td><td>Maximum number of clusters. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True, if clustering succeded. </dd></dl>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="f842fcee4e13cf8516379ed25ba363cc"></a><!-- doxytag: member="IterativeKMeans::clusterid" ref="f842fcee4e13cf8516379ed25ba363cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int&gt; <a class="el" href="classIterativeKMeans.html#f842fcee4e13cf8516379ed25ba363cc">clusterid</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Points (vectors) to be clustered 
<p>
Definition at line <a class="el" href="ikmeans_8h-source.html#l00032">32</a> of file <a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>.
<p>
Referenced by <a class="el" href="ikmeans_8h-source.html#l00107">getClusterIds()</a>.
</div>
</div><p>
<a class="anchor" name="b42aafa792eefc3441e12abcf94bc4e9"></a><!-- doxytag: member="IterativeKMeans::centroids" ref="b42aafa792eefc3441e12abcf94bc4e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;int&gt; &gt; <a class="el" href="classIterativeKMeans.html#b42aafa792eefc3441e12abcf94bc4e9">centroids</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cluster ids assigned to each point 
<p>
Definition at line <a class="el" href="ikmeans_8h-source.html#l00033">33</a> of file <a class="el" href="ikmeans_8h-source.html">ikmeans.h</a>.
<p>
Referenced by <a class="el" href="ikmeans_8h-source.html#l00115">getCentroids()</a>.
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>Recommender/MiningAlgorithm/include/ikmeans/<a class="el" href="ikmeans_8h-source.html">ikmeans.h</a></ul>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Nov 13 18:41:22 2010 for ModuloRecommender by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
